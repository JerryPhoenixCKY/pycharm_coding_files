# # P1047 [NOIP 2005 普及组] 校门外的树
#
# ## 题目描述
#
# 某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。
# 由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。
# 输入格式
# 第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。
# 接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。
# ## 输出格式
#
# 输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。
#
# ## 输入输出样例 #1
#
# ### 输入 #1
#
# ```
# 500 3
# 150 300
# 100 200
# 470 471
# ```
#
# ### 输出 #1
# 298


# 读取输入
l, m = map(int, input().split())

# 存储被移除的树的位置
removed = set()

# 处理每个区间
for _ in range(m):
    u, v = map(int, input().split())
    # 将区间 [u, v] 中的所有整数点加入集合
    for pos in range(u, v + 1):
        removed.add(pos)

# 剩余的树的数量
remaining = (l + 1) - len(removed)
print(remaining)

# ------------------------------------------------------------
# 差分数组法
l, m = map(int, input().split())

# 差分数组，标记每个位置是否被覆盖
diff = [0] * (l + 2)  # 避免越界

for _ in range(m):
    u, v = map(int, input().split())
    diff[u] += 1
    diff[v + 1] -= 1

# 计算前缀和，得到每个位置是否被覆盖
covered = 0
count_removed = 0
for i in range(l + 1):
    covered += diff[i]
    if covered > 0:
        count_removed += 1

print((l + 1) - count_removed)