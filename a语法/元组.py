#
# ## 一、元组的基本特性
# | 特性 | 说明 |
# |------|------|
# | **有序** | 元素按插入顺序存储，可通过索引访问（如 `t[0]`） |
# | **不可变（immutable）** | 创建后不能添加、删除或修改元素 |
# | **可嵌套** | 元素可以是其他元组、列表、字典等 |
# | **可哈希（如果元素都可哈希）** | 可作为字典的键或集合的元素（前提是所有元素都不可变） |
# | **支持重复元素** | 允许相同值多次出现 |
# ## 二、如何创建元组
#
# ### 1. 使用圆括号 `()`
# ```python
# t = (1, 2, 3)
# ```
#
# ### 2. 省略括号（仅在明确上下文中）
# ```python
# t = 1, 2, 3        # 合法，但不推荐用于复杂表达式
# ```
#
# ### 3. 创建单元素元组（注意逗号！）
# ```python
# t = (42,)          # 正确：这是一个元组
# t = (42)           # 错误：这只是一个整数 42
# t = 42,            # 也可以（带逗号）
# ```
#
# ### 4. 使用 `tuple()` 构造函数
# ```python
# t = tuple([1, 2, 3])     # 从列表创建 → (1, 2, 3)
# t = tuple("abc")         # 从字符串创建 → ('a', 'b', 'c')
# t = tuple()              # 空元组 → ()
# ```
#
# ---
#
# ## 三、元组的常用操作
#
# ### 1. 索引与切片（只读）
# ```python
# t = ('a', 'b', 'c', 'd')
# print(t[0])      # 'a'
# print(t[-1])     # 'd'
# print(t[1:3])    # ('b', 'c')
# ```
#
# > ❌ 不能赋值：`t[0] = 'x'` 会抛出 `TypeError`
#
# ### 2. 连接与重复
# ```python
# t1 = (1, 2)
# t2 = (3, 4)
# t3 = t1 + t2     # (1, 2, 3, 4)
# t4 = t1 * 3      # (1, 2, 1, 2, 1, 2)
# ```
#
# ### 3. 成员检测
# ```python
# 'a' in ('a', 'b')   # True
# ```
#
# ### 4. 长度、最大值、最小值、计数等
# ```python
# t = (3, 1, 4, 1, 5)
# len(t)        # 5
# max(t)        # 5
# min(t)        # 1
# t.count(1)    # 2（出现次数）
# t.index(4)    # 2（首次出现的索引）
# ```
#
# ### 5. 解包（unpacking）—— 非常常用！
# ```python
# point = (3, 4)
# x, y = point
# print(x, y)  # 3 4
#
# # 交换变量（无需临时变量）
# a, b = 1, 2
# a, b = b, a
#
# # 使用 * 解包（Python 3+）
# first, *middle, last = (1, 2, 3, 4, 5)
# # first=1, middle=[2,3,4], last=5
# ```
#
# ---
#
# ## 四、元组 vs 列表
#
# | 特性 | 元组（tuple） | 列表（list） |
# |------|---------------|--------------|
# | 可变性 | ❌ 不可变 | ✅ 可变 |
# | a语法 | `(1, 2, 3)` | `[1, 2, 3]` |
# | 性能 | 更快、内存更小 | 稍慢、开销大 |
# | 用途 | 表示**结构化数据**（如坐标、RGB值） | 表示**可变集合**（如购物车） |
# | 可哈希 | ✅（若元素都可哈希） | ❌ 不可哈希 |
# | 方法数量 | 少（只有 `.count()`, `.index()`） | 多（`.append()`, `.pop()`, `.sort()` 等） |
#
# ---
#
# ## 五、典型使用场景
#
# ### 1. 表示固定结构的数据
# # 坐标
# position = (10, 20)
#
# # RGB颜色
# color = (255, 128, 0)
#
# # 数据库记录（只读）
# record = ("Alice", 30, "Engineer")
# ```
#
# ### 2. 函数返回多个值（实际返回一个元组）
# ```python
# def get_name_age():
#     return "Bob", 25  # 等价于 return ("Bob", 25)
#
# name, age = get_name_age()
# ```
#
# ### 3. 作为字典的键（因为可哈希）
# ```python
# locations = {
#     (0, 0): "origin",
#     (1, 1): "diagonal"
# }
# print(locations[(0, 0)])  # "origin"
# ```
#
# ### 4. 保证数据不被意外修改
# ```python
# CONFIG = ("localhost", 8080, "debug")  # 防止程序中途被篡改
# ```
#
# ---
#
# ## 六、常见误区
#
# ### ❌ 误区1：元组完全不可变？
# - 元组本身不可变，但如果元素是**可变对象**（如列表），其内容仍可修改：
#   ```python
#   t = ([1, 2], 'a')
#   t[0].append(3)   # 合法！t 变成 ([1, 2, 3], 'a')
#   ```
#   > 元组的“不可变”指的是**元素引用不可变**，不是元素内容不可变。
#
# ### ❌ 误区2：`()` 总是表示元组？
# - 空括号 `()` 是空元组；
# - 但 `(x)` 只是加了括号的表达式，不是元组；
# - 必须有逗号：`(x,)` 才是单元素元组。
# ## 七、总结
#
# ✅ **元组适合用于：**
# - 表示**结构固定、不应被修改**的数据；
# - 需要**高性能、低内存开销**的场景；
# - 作为**字典键**或**集合元素**；
# - 函数**返回多个值



# first, *middle, last = (1, 2, 3, 4, 5)
# 🔍 一、整体含义
# 这行代码的作用是：
#
# 从一个至少包含两个元素的可迭代对象（这里是元组 (1, 2, 3, 4, 5)）中，
# 把第一个元素赋给变量 first，
# 把最后一个元素赋给变量 last，
# 把中间所有剩余的元素收集到一个列表中，赋给变量 middle。
# 🧩 二、各部分解析
# 1. 左侧：first, *middle, last
# 这是一个解包目标（unpacking target）。
# *middle 中的星号 * 表示：“把剩下的所有元素打包成一个列表，赋给 middle”。
# 星号只能出现一次在解包表达式中。
# first 和 last 是普通变量，分别接收第一个和最后一个值。
# 2. 右侧：(1, 2, 3, 4, 5)
# 一个包含 5 个整数的元组（也可以是列表、字符串等任意可迭代对象）。
# ✅ 三、执行结果
# 执行后，变量的值为：
#
# first  → 1
# middle → [2, 3, 4]   # 注意：是列表，不是元组！
# last   → 5
# 💡 即使原始数据是元组，*middle 收集的结果总是列表。
#
# 📌 四、规则与限制
# ✅ 规则 1：可迭代对象长度 ≥ 2
# 因为要同时取 first 和 last，所以至少需要两个元素：
#
# # 合法
# a, *b, c = (1, 2)        # a=1, b=[], c=2
#
# # 非法（报错）
# a, *b, c = (1,)          # ValueError: not enough values to unpack
# ✅ 规则 2：* 只能出现一次
#
# # 错误！
# *a, *b = [1, 2, 3]       # SyntaxError
# ✅ 规则 3：* 可以出现在任意位置（但通常放中间）
#
# *beginning, last = (1, 2, 3, 4, 5)
# # beginning = [1, 2, 3, 4], last = 5
#
# first, *rest = (1, 2, 3, 4, 5)
# # first = 1, rest = [2, 3, 4, 5]


## 一、什么是“可哈希”（Hashable）？

# 在 Python 中，一个对象是 **可哈希的（hashable）**，当且仅当：
# 1. 它在其生命周期内**具有不变的哈希值**（即 `hash(obj)` 始终相同）；
# 2. 它可以与其他对象进行**相等性比较**（即支持 `__eq__` 方法）；
# 3. **相等的对象必须具有相同的哈希值**。
#
# > ✅ 所有**不可变的内置类型**（如 `int`, `float`, `str`, `tuple`, `frozenset`）通常是可哈希的。
# > ❌ 所有**可变类型**（如 `list`, `dict`, `set`）是**不可哈希的**。
#
# 你可以用 `hash()` 函数测试：
#
# ```python
# hash((1, 2))      # ✅ 成功，返回一个整数
# hash([1, 2])      # ❌ 报错：TypeError: unhashable type: 'list'
# ```
#
# ---
#
# ## 二、为什么字典的键必须是可哈希的？
#
# Python 的 `dict` 底层使用**哈希表（hash table）** 实现，其工作原理是：
# 1. 对键调用 `hash(key)` 得到一个整数（哈希值）；
# 2. 用这个哈希值快速定位存储位置（“桶”）；
# 3. 如果多个键哈希到同一位置（哈希冲突），再用 `==` 比较键是否真正相等。
#
# 👉 **如果键是可变的**（比如列表），那么：
# - 插入字典后，如果修改了列表内容，它的哈希值会变（但实际上 Python 不允许计算可变对象的哈希值）；
# - 即使能算，字典也无法再找到原来的存储位置，导致数据“丢失”或逻辑混乱。
#
# 因此，**Python 强制要求字典的键必须是可哈希的**。
#
# ---
#
# ## 三、元组为什么可以作为字典的键？
#
# ### ✅ 情况1：元组中所有元素都可哈希
# ```python
# d = {}
# key = (1, "a", 3.14)      # 元素都是不可变类型
# d[key] = "value"
# print(d)  # {(1, 'a', 3.14): 'value'}
# ```
# - 因为 `(1, "a", 3.14)` 是**不可变的**，且所有元素都可哈希；
# - 所以整个元组是可哈希的，能作为字典键。
#
# ### ❌ 情况2：元组中包含不可哈希元素
# ```python
# key = (1, [2, 3])         # 包含列表（不可哈希）
# d[key] = "value"          # ❌ TypeError: unhashable type: 'list'
# ```
# - 虽然元组本身不可变，但**它包含了一个可变对象（列表）**；
# - Python 无法保证整个结构的哈希值稳定，因此该元组**不可哈希**。
#
# > 🔍 判断元组是否可哈希的规则：**只有当元组中所有元素都可哈希时，该元组才是可哈希的**。
#
# ---
#
# ## 四、对比：元组 vs 列表 作为键
#
# | 类型 | 可变性 | 可哈希？ | 能否作字典键？ |
# |------|--------|----------|----------------|
# | `tuple` | ❌ 不可变 | ✅（若元素都可哈希） | ✅ 可以 |
# | `list`  | ✅ 可变   | ❌ 不可哈希         | ❌ 不行 |
#
# ```python
# # 正确
# d = {(0, 0): "origin"}
#
# # 错误
# d = {[0, 0]: "origin"}  # TypeError
# ```
#
# ---
#
# ## 五、实际应用场景
#
# ### 1. 用坐标作为键
# ```python
# grid = {
#     (0, 0): "start",
#     (1, 2): "treasure",
#     (-1, 3): "trap"
# }
# ```
#
# ### 2. 多维键（如缓存函数参数）
# ```python
# cache = {}
#
# def expensive_func(a, b, c):
#     key = (a, b, c)  # 参数组合做键
#     if key in cache:
#         return cache[key]
#     # ... 计算 ...
#     cache[key] = result
#     return result
# ```
#
# ### 3. 表示复合主键（如数据库记录）
# ```python
# user_permissions = {
#     ("Alice", "read"): True,
#     ("Bob", "write"): False
# }
#
# ## 六、常见误区澄清
#
# ### ❌ 误区： “元组总是可哈希的”
# → **错误！** 只有**元素全部可哈希**的元组才是可哈希的。
#
# ### ❌ 误区： “不可变 = 可哈希”
# → **基本正确，但有例外**。Python 要求不可变对象**同时实现 `__hash__` 方法**。用户自定义类即使不可变，若未定义 `__hash__`，也可能不可哈希。
#
# ---
#
# ## 七、总结
#
# - ✅ **元组可以作为字典的键，前提是它包含的所有元素都是可哈希的**。
# - 🔒 这得益于元组的**不可变性**和 Python 对**哈希一致性**的要求。
# - 🚫 列表、字典、集合等可变类型**永远不能作为字典键**。
# - 💡 利用元组作键，可以优雅地表示**多维、结构化**的键，是 Python 中的常见模式。
#
# > 🐍 **记住**：
# > **“字典的键必须是不可变且可哈希的——元组在满足条件时，正是理想选择。”**